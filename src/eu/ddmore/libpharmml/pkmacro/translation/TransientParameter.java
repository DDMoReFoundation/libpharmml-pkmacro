/*******************************************************************************
 * Copyright (c) 2015-2016 European Molecular Biology Laboratory,
 * Heidelberg, Germany.
 *
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy of
 * the License at
 *
 * 		http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, 
 * software distributed under the License is distributed on 
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
 * KIND, either express or implied. See the License for the 
 * specific language governing permissions and limitations 
 * under the License.
 *******************************************************************************/
package eu.ddmore.libpharmml.pkmacro.translation;

import eu.ddmore.libpharmml.dom.commontypes.Assignable;
import eu.ddmore.libpharmml.dom.commontypes.Delay;
import eu.ddmore.libpharmml.dom.commontypes.Interpolation;
import eu.ddmore.libpharmml.dom.commontypes.Interval;
import eu.ddmore.libpharmml.dom.commontypes.Matrix;
import eu.ddmore.libpharmml.dom.commontypes.MatrixSelector;
import eu.ddmore.libpharmml.dom.commontypes.Product;
import eu.ddmore.libpharmml.dom.commontypes.Rhs;
import eu.ddmore.libpharmml.dom.commontypes.Scalar;
import eu.ddmore.libpharmml.dom.commontypes.Sequence;
import eu.ddmore.libpharmml.dom.commontypes.Sum;
import eu.ddmore.libpharmml.dom.commontypes.SymbolRef;
import eu.ddmore.libpharmml.dom.commontypes.Vector;
import eu.ddmore.libpharmml.dom.commontypes.VectorSelector;
import eu.ddmore.libpharmml.dom.maths.Binop;
import eu.ddmore.libpharmml.dom.maths.Constant;
import eu.ddmore.libpharmml.dom.maths.Equation;
import eu.ddmore.libpharmml.dom.maths.FunctionCallType;
import eu.ddmore.libpharmml.dom.maths.MatrixUniOp;
import eu.ddmore.libpharmml.dom.maths.Piecewise;
import eu.ddmore.libpharmml.dom.maths.Uniop;
import eu.ddmore.libpharmml.dom.modeldefn.CommonParameter;
import eu.ddmore.libpharmml.dom.modeldefn.IndividualParameter;
import eu.ddmore.libpharmml.dom.modeldefn.PopulationParameter;
import eu.ddmore.libpharmml.dom.modeldefn.Probability;
import eu.ddmore.libpharmml.dom.modeldefn.SimpleParameter;

/**
 * A wrapper class for parameters generated by the PKmacro translation. This wrapper is used instead of using directly the 
 * XML-mapped parameter classes because of the potential different nature of the wrapped parameter depending on the 
 * PharmML model version. For instance, in PharmML older than 0.7.3, parameters are generated as {@link SimpleParameter}, while
 * the new parameter type is {@link PopulationParameter} for PharmML 0.7.3 and superior.
 * 
 * @author Florent Yvon
 *
 */
@SuppressWarnings("deprecation")
class TransientParameter implements Assignable {
	
	private final String symbolId;
	private Rhs assign;
	private ParameterType type;
	
	private SimpleParameter sp;
	private PopulationParameter pp;
	private IndividualParameter ip;
	
	TransientParameter(String symbolId, ParameterType type) {
		this.symbolId = symbolId;
		this.type = type;
	}
	
	TransientParameter(SimpleParameter sp){
		this.sp = sp;
		symbolId = sp.getId();
		this.type = null;
	}
	
	TransientParameter(PopulationParameter pp){
		this.pp = pp;
		symbolId = pp.getId();
		this.type = ParameterType.POPULATION;
	}
	
	TransientParameter(IndividualParameter ip){
		this.ip = ip;
		symbolId = ip.getId();
		this.type = ParameterType.INDIVIDUAL;
	}
	
	/**
	 * Gets the initial parameter which this transient instance was built on.
	 * @return The {@link CommonParameter} reference object used to build this transient parameter.
	 */
	public CommonParameter getReference(){
		if(sp != null){
			return sp;
		} else if(pp != null) {
			return pp;
		} else if(ip != null) {
			return ip;
		} else {
			return null;
		}
	}
	
	/**
	 * Checks if this transient parameter was built on an existing PharmML parameter.
	 * @return true if this instance contains an existing PharmML object.
	 */
	boolean containsReference(){
		return (sp != null || pp != null || ip != null);
	}
	
	String getSymbolId(){
		return symbolId;
	}
	
	public void setAssign(Rhs rhs){
		this.assign = rhs;
	}
	
	public Rhs getAssign(){
		return assign;
	}
	
	public ParameterType getType(){
		return type;
	}
	
	/**
	 * Creates a new {@link SimpleParameter} from this transient instance. This method sould be used only for
	 * models encoded in old versions prior to 0.7.
	 * @return A new {@link SimpleParameter}.
	 */
	SimpleParameter toSimpleParameter(){
		SimpleParameter sp = new SimpleParameter();
		sp.setSymbId(symbolId);
		sp.setAssign(assign);
		return sp;
	}
	
	/**
	 * Creates a new {@link PopulationParameter} from this transient instance.
	 * @return A new {@link PopulationParameter}.
	 */
	PopulationParameter toPopulationParameter(){
		PopulationParameter pp = new PopulationParameter();
		pp.setSymbId(symbolId);
		pp.setAssign(assign);
		return pp;
	}
	
	/**
	 * Creates a new {@link IndividualParameter} from this transient instance.
	 * @return A new {@link IndividualParameter}.
	 */
	IndividualParameter toIndiviualParameter(){
		IndividualParameter ip = new IndividualParameter();
		ip.setSymbId(symbolId);
		ip.setAssign(assign);
		return ip;
	}
	
	@Override
	public Rhs assign(Scalar scalar) {
		Rhs rhs = new Rhs(scalar);
		setAssign(rhs);
		return rhs;
	}

	@Deprecated
	public Rhs assign(Equation equation) {
		Rhs rhs = new Rhs(equation);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(SymbolRef symbolRef) {
		Rhs rhs = new Rhs(symbolRef);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Sequence sequence) {
		Rhs rhs = new Rhs(sequence);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Vector vector) {
		Rhs rhs = new Rhs(vector);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Interpolation interpolation) {
		Rhs rhs = new Rhs(interpolation);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Matrix matrix) {
		Rhs rhs = new Rhs(matrix);
		setAssign(rhs);
		return rhs;
	}
	
	@Override
	public Rhs assign(Constant constant) {
		Rhs rhs = new Rhs(constant);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Interval interval) {
		Rhs rhs = new Rhs(interval);
		setAssign(rhs);
		return rhs;
	}
	
	@Override
	public Rhs assign(Binop binop) {
		Rhs rhs = new Rhs(binop);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Uniop uniop) {
		Rhs rhs = new Rhs(uniop);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Piecewise piecewise) {
		Rhs rhs = new Rhs(piecewise);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(FunctionCallType functionCall) {
		Rhs rhs = new Rhs(functionCall);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Sum sum) {
		Rhs rhs = new Rhs(sum);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Product product) {
		Rhs rhs = new Rhs(product);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Delay delay) {
		Rhs rhs = new Rhs(delay);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(VectorSelector vectorSelector) {
		Rhs rhs = new Rhs(vectorSelector);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(MatrixSelector matrixSelector) {
		Rhs rhs = new Rhs(matrixSelector);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(MatrixUniOp matrixUniop) {
		Rhs rhs = new Rhs(matrixUniop);
		setAssign(rhs);
		return rhs;
	}

	@Override
	public Rhs assign(Probability probability) {
		Rhs rhs = new Rhs(probability);
		setAssign(rhs);
		return rhs;
	}
	

}
